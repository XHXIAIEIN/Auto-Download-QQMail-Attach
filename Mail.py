#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#===============================================================================
# * å£°æ˜
#===============================================================================
# ä½œè€…ï¼šXHXIAIEIN
# æ›´æ–°ï¼š2024/05/20
# ä¸»é¡µï¼šhttps://github.com/XHXIAIEIN/Auto-Download-QQMail-Attach
#===============================================================================

'''
#===============================================================================
# * å¦‚ä½•å®‰è£…
#===============================================================================
'''

#-------------------------------------------------------------------------------
# ğŸˆ å¿…è¦çš„è½¯ä»¶ 1: Python
#-------------------------------------------------------------------------------
#  - python3:   
#  https://www.python.org/downloads/
#  
#  æ‰“å¼€é¡µé¢ï¼Œç‚¹å‡»ç½‘é¡µæœ€é†’ç›®çš„é»„è‰²æŒ‰é’®ã€‚"Download Python 3.xxx" (xxx ä¸ºæœ€æ–°ç‰ˆæœ¬å·)
#  
#  Windows å®‰è£…è¡¥å……ï¼š
#  å®‰è£…æ—¶ï¼Œéœ€å‹¾é€‰å®‰è£…é¡µé¢åº•éƒ¨é€‰é¡¹ âŒˆAdd Python 3.xx to PATHâŒ‹
#...............................................................................


#-------------------------------------------------------------------------------
# ğŸˆ å¿…è¦çš„è½¯ä»¶ 2: Chromedriver 
#-------------------------------------------------------------------------------
#  - chromedriver: 
#  https://googlechromelabs.github.io/chrome-for-testing/#stable
# 
#  æ‰“å¼€è¿™ä¸ªé¡µé¢ï¼Œä¼šçœ‹åˆ°ä¸€ä¸ªç»¿è‰²çš„è¡¨æ ¼ã€‚
#  æ‰¾åˆ°å…¶ä¸­çš„ chromedriverï¼Œ
#  1. å…ˆçœ‹ç¬¬ 1 åˆ—çš„ chromedriverï¼Œä¼šå‘ç°æœ‰å¾ˆå¤šä¸åŒçš„å¹³å°ã€‚
#  2. å†çœ‹ç¬¬ 2 åˆ—çš„ Platformï¼Œæ‰¾åˆ°ä½ å¯¹åº”çš„æ“ä½œç³»ç»Ÿï¼š
#           Windows ç³»ç»Ÿï¼Œä¸‹è½½ win64 æˆ– win32 ç‰ˆæœ¬ï¼›
#           MacOS ç³»ç»Ÿï¼ŒIntelå¤„ç†å™¨ä¸‹è½½ mac-x64 ç‰ˆæœ¬ï¼ŒM1/M2 å¤„ç†å™¨ä¸‹è½½ mac-arm64 ç‰ˆæœ¬ã€‚
#  3. å†çœ‹ç¬¬ 3 åˆ—çš„ URLï¼Œå°†åœ°å€å¤åˆ¶åˆ°æµè§ˆå™¨åœ°å€æ ï¼ŒæŒ‰ä¸‹å›è½¦ï¼Œå³å¯ä¸‹è½½ã€‚
#
#  å®‰è£…è¡¥å……ï¼š
#  ä¸‹è½½å®Œæˆåï¼Œå°†å‹ç¼©åŒ…è¿›è¡Œè§£å‹ï¼Œæ”¾åˆ°å’Œè¿™ä¸ªè„šæœ¬æ–‡ä»¶ç›¸åŒçš„ç›®å½•ã€‚
#...............................................................................


#-------------------------------------------------------------------------------
# ğŸˆ å¿…è¦çš„ä¾èµ–åº“
#-------------------------------------------------------------------------------
#  Windowsç”¨æˆ·ï¼š
#  æŒ‰ä¸‹ Win + R æ‰“å¼€ cmdï¼Œåœ¨å‘½ä»¤æç¤ºç¬¦è¾“å…¥ä»¥ä¸‹æŒ‡ä»¤ï¼š
#  python -m pip install --upgrade pip
#  pip install selenium
# 
#  æ³¨ï¼šè‹¥ç½‘ç»œé—®é¢˜æ— æ³•ä¸‹è½½æˆ–ä¸‹è½½è¿‡æ…¢ï¼Œå¯å°è¯•ä½¿ç”¨å›½å†…é•œåƒæºï¼Œåœ¨åé¢åŠ å…¥ -i å‚æ•°ï¼š
#  pip install helium -i https://pypi.tuna.tsinghua.edu.cn/simple
#...............................................................................
#  MacOSç”¨æˆ·ï¼š
#  è¿è¡Œç»ˆç«¯(Terminal)è¾“å…¥ä»¥ä¸‹æŒ‡ä»¤ï¼š
#  python -m pip install helium
#...............................................................................

# ä»¥ä¸‹æ˜¯æœ¬è„šæœ¬ä½¿ç”¨åˆ°çš„å®˜æ–¹åº“
from selenium import webdriver
from selenium.webdriver import Chrome
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.keys import Keys
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from urllib import parse
import os, re, sys, time, shutil, csv

'''
#===============================================================================
# * è‡ªå®šä¹‰å‚æ•°
#===============================================================================
'''

class PROFILE:

    # è¦ä¸‹è½½çš„é‚®ç®±æ–‡ä»¶å¤¹ID
    FOLDER_ID = 123

    # é™„ä»¶ä¸‹è½½åˆ°æœ¬åœ°å“ªä¸ªä½ç½®
    ROOTPATH = r'D:\QQMailDownload\2024'

    # ä¸´æ—¶æ–‡ä»¶è·¯å¾„
    DOWNLOAD_FOLDER = os.path.join(ROOTPATH, 'download2')
    USERDATA_FOLDER = os.path.join(ROOTPATH, 'selenium')

    #---------------------------------------------------------------------------
    # ï¼ˆå¯é€‰ï¼‰ä¸‹è½½è®¡åˆ’
    #---------------------------------------------------------------------------
    #  start:     ä»é‚®ä»¶åˆ—è¡¨ç¬¬nä¸ªå¼€å§‹ã€‚ï¼ˆåŒ…å«nï¼Œå³åˆ—è¡¨ç¬¬ä¸€ä¸ªå°±æ˜¯nã€‚ï¼‰é»˜è®¤å€¼ï¼š1
    #  end:       åˆ°é‚®ä»¶åˆ—è¡¨ç¬¬nä¸ªç»“æŸã€‚ï¼ˆåŒ…å«nï¼Œå³åˆ—è¡¨æœ€åä¸€ä¸ªæ˜¯nã€‚ï¼‰é»˜è®¤å€¼ï¼š0
    #  step:      ä»startå¼€å§‹è®¡ç®—ï¼Œç´¯è®¡ä¸‹è½½nä¸ªåç»“æŸã€‚ï¼ˆå³éœ€ä¸‹è½½nä¸ªï¼‰é»˜è®¤å€¼ï¼š0
    #---------------------------------------------------------------------------

    # é‚®ä»¶åˆ—è¡¨
    TITLE_TASK = { 'start':1, 'step':0, 'end':0 }

    # ç¿»é¡µè§„åˆ™
    PAGES_TASK = { 'start':1, 'step':0, 'end':0 }

    #---------------------------------------------------------------------------
    # ï¼ˆå¯é€‰ï¼‰é‚®ä»¶ä¸»é¢˜ï¼Œå…³é”®è¯è¿‡æ»¤
    #---------------------------------------------------------------------------

    # é»‘åå•å…³é”®è¯ã€‚é‚®ä»¶ä¸»é¢˜å¦‚æœåŒ…å«äº†ä»»æ„ä¸€ä¸ªå…³é”®è¯ï¼Œå°±å¿½ç•¥ä¸ä¸‹è½½ã€‚
    # ç¤ºä¾‹ï¼šTITLE_BACKLIST_KEYS = ['å‘ä¿¡æ–¹å·²æ’¤å›é‚®ä»¶','QQä¼šå‘˜ä¸šåŠ¡é€šçŸ¥é‚®ä»¶']
    TITLE_BACKLIST_KEYS = ['å‘ä¿¡æ–¹å·²æ’¤å›é‚®ä»¶', 'è‡ªåŠ¨å›å¤']

    # é»‘åå•å…³é”®è¯ã€‚æ ‡ç­¾å¦‚æœåŒ…å«äº†ä»»æ„ä¸€ä¸ªå…³é”®è¯ï¼Œå°±å¿½ç•¥ä¸ä¸‹è½½ã€‚
    # ç¤ºä¾‹ï¼šTITLE_BACKLIST_KEYS = ['å·²é˜…']
    TAG_BACKLIST_KEYS = ['å·²é˜…']

    # ç™½åå•å…³é”®è¯ã€‚é‚®ä»¶ä¸»é¢˜å¿…é¡»åŒ…å«ç™½åå•é‡Œçš„æ‰€æœ‰å…³é”®è¯ã€‚å…³é”®è¯è¶Šå¤šï¼ŒåŒ¹é…è§„åˆ™è¶Šä¸¥æ ¼ã€‚
    # ç¤ºä¾‹ï¼šTITLE_BACKLIST_KEYS = ['åé¦ˆ','å›å¤']
    TITLE_WHITELIST_KEYS = ['']

    #---------------------------------------------------------------------------

    # ç›´æ¥è·³è¿‡æ²¡æœ‰é™„ä»¶çš„é‚®ä»¶ã€‚
    # å¯ç”¨åï¼Œè‡ªåŠ¨æ·»åŠ  "æ²¡æœ‰é™„ä»¶" æ ‡ç­¾çš„åŠŸèƒ½å°†å¤±æ•ˆã€‚
    SKIP_NO_ATTACH = 1

    # ä¸‹è½½å‰ï¼Œæ£€æµ‹æœ¬åœ°æ˜¯å¦å­˜åœ¨ç›¸åŒæ–‡ä»¶ï¼ˆæ£€æµ‹æ–¹æ³•ï¼šå¯¹æ¯”æ–‡ä»¶ååŠæ–‡ä»¶å¤§å°æ˜¯å¦ä¸€è‡´ï¼‰ã€‚
    SKIP_EXISTS_FILE = 1

    # æ¯ä¸ªé‚®ä»¶å°†åˆ›å»ºä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œå°†é™„ä»¶ä¸‹è½½åˆ°å…¶ä¸­ã€‚
    CREATE_FOLDER_EACH_TITLE = 1
    CREATE_FOLDER_NAME = "{titleindex}_{fromname}"

    # æ˜¯å¦éœ€è¦ä¸‹è½½é™„ä»¶
    CAN_DOWNLOAD_ATTACH = 1
    
    # åŒæ—¶ä¸‹è½½æ–‡ä»¶æ•°é‡
    MAX_CONCURRENT_DOWNLOADS = 5

    # å•ä¸ªæ–‡ä»¶ä¸‹è½½è¶…æ—¶(ç§’)
    DOWNLOAD_TIME_OUT = 60
    
    # æ²¡æœ‰é™„ä»¶æ·»åŠ æ˜Ÿæ ‡
    CAN_STAR_NO_ATTACH = 1

    # TODO
    # # æ²¡æœ‰é™„ä»¶æ·»åŠ æ ‡ç­¾
    # CAN_TAG_NO_ATTACH = 1
    # STR_TAG_NO_ATTACH = 'æ²¡æœ‰é™„ä»¶'

    # # è¿‡æœŸé™„ä»¶æ·»åŠ æ ‡ç­¾
    # CAN_TAG_TIMEOUT_ATTACH = 1
    # STR_TAG_TIMEOUT_ATTACH = 'è¿‡æœŸé™„ä»¶'

    # # ä¸è§„èŒƒå‘½åçš„é™„ä»¶æ·»åŠ æ ‡ç­¾
    # CAN_TAG_FILENAME_ATTACH = 1
    # STR_TAG_FILENAME_ATTACH = 'é‡å‘½å'


'''
#===============================================================================
#                 " è¯· å‹¿ è·¨ è¿‡ è¿™ å— åŒº åŸŸ ä¿® æ”¹ å†… å®¹ "
#===============================================================================
'''

#-------------------------------------------------------------------------------
# æœ¬åœ°å˜é‡
#-------------------------------------------------------------------------------

# å¯åŠ¨æ—¶é—´
start_time = datetime.now().strftime("%Y-%m-%d")

# æœ¬åœ°ç¼“å­˜æ•°æ®
LOCALDATA = {
  'folder_id'     : PROFILE.FOLDER_ID,       # åœ°å€å‚æ•°ï¼šæ–‡ä»¶å¤¹çš„ID
  'token_page'    : 0,                       # åœ°å€å‚æ•°ï¼šæ–‡ä»¶å¤¹é¡µæ•°
  'token_sid'     : '',                      # åœ°å€å‚æ•°ï¼šèº«ä»½å¯†é’¥
  'folder_name'   : '',                      # æ–‡ä»¶å¤¹åç§°ï¼ˆé¦–æ¬¡è¿›æ–‡ä»¶å¤¹è¯»å–)
  'page_count'    : 0,                       # æ–‡ä»¶å¤¹æ€»é¡µæ•°(é¦–æ¬¡è¿›æ–‡ä»¶å¤¹è¯»å–)
  'title_count'   : 0,                       # æ–‡ä»¶å¤¹æ€»é‚®ä»¶æ•°é‡(é¦–æ¬¡è¿›æ–‡ä»¶å¤¹è¯»å–)
  'page_title'    : 0,                       # æ¯é¡µæœ‰å¤šå°‘å°é‚®ä»¶(æ¯æ¬¡è¿›æ–‡ä»¶å¤¹è¯»å–)
  'title_list'    : [],
  'attach_list'   : [],
}


# å½“å‰å¾ªç¯ç¼“å­˜æ•°æ®
TEMP_DATA = {
    'nextpage'      :  1,                    # æ˜¯å¦éœ€è¦ä¸‹ä¸€é¡µ,ç”¨äºä¸‹è½½è®¡åˆ’çš„è·³è¿‡
    'title_index'   :  0,                    # å½“å‰å¤„ç†é‚®ä»¶åº
    'page'          :  0,                    # å½“å‰å¤„ç†é¡µ
    'title'         :  0,                    # å½“å‰é‚®ä»¶æ€»åº
    'title_at'      :  0,                    # å½“å‰é‚®ä»¶é¡µåº
    'attach'        :  0,                    # å½“å‰é™„ä»¶æ€»åº
    'attach_at'     :  0                     # å½“å‰é™„ä»¶é¡µåº
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------

driver = None

# åŠ è½½å·²æœ‰çš„ä¸´æ—¶æ•°æ®æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
def load_temporary_data():
    global LOCALDATA

    LOCALDATA['temp_title_path'] = os.path.join(PROFILE.ROOTPATH, f"{PROFILE.FOLDER_ID}_title_data.csv")
    LOCALDATA['temp_attach_path'] = os.path.join(PROFILE.ROOTPATH, f"{PROFILE.FOLDER_ID}_attach_data.csv")

    # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    title_file_exists = os.path.isfile(LOCALDATA['temp_title_path'])
    attach_file_exists = os.path.isfile(LOCALDATA['temp_attach_path'])

    # æ–‡ä»¶ä¸å­˜åœ¨
    if not title_file_exists and not attach_file_exists:
        return False

    # å¦‚æœä»»ä¸€æ–‡ä»¶å­˜åœ¨ï¼Œæç¤ºç”¨æˆ·å¤„ç†æ–¹å¼
    if title_file_exists or attach_file_exists:
        print('----------------------------------------')
        print("æ£€æµ‹åˆ°å­˜åœ¨ä¸´æ—¶æ•°æ®æ–‡ä»¶:")
        if title_file_exists: print(f"æ ‡é¢˜æ•°æ®: {LOCALDATA['temp_title_path']}")
        if attach_file_exists: print(f"é™„ä»¶æ•°æ®: {LOCALDATA['temp_attach_path']}")
        print('----------------------------------------')
        print("è¯·è¾“å…¥ 1 æˆ– 0 æŒ‡ä»¤é€‰æ‹©å¤„ç†æ–¹å¼:")
        print("1. è¿›åº¦ç»§ç»­ï¼Œç›´æ¥ä¸‹è½½é™„ä»¶")
        print("0. é‡æ–°å¼€å§‹ï¼Œåˆ é™¤ç¼“å­˜æ•°æ®")

        # è·å–ç”¨æˆ·è¾“å…¥
        user_input = input("è¯·è¾“å…¥æŒ‡ä»¤ï¼Œç•™ç©ºåˆ™é»˜è®¤ä½¿ç”¨ç°æœ‰æ•°æ®: ").strip() or '1'
        print('----------------------------------------')
        if user_input == '1':
            # ä½¿ç”¨æ–‡ä»¶æ•°æ®æ›¿æ¢å½“å‰æ•°æ®
            if title_file_exists:
                with open(LOCALDATA['temp_title_path'], 'r', newline='', encoding='utf-8') as title_file:
                    reader = csv.DictReader(title_file)
                    title_list = list(reader)
                    filtered_titles = apply_download_schedule(title_list, PROFILE.TITLE_TASK)
                    LOCALDATA['title_list'] = filtered_titles
                    print(f"è¯»å– {len(filtered_titles)} æ¡é‚®ä»¶æ•°æ®ã€‚")
            if attach_file_exists:
                with open(LOCALDATA['temp_attach_path'], 'r', newline='', encoding='utf-8') as attach_file:
                    reader = csv.DictReader(attach_file)
                    attach_list = list(reader)
                    filtered_attachments = apply_download_schedule(attach_list, PROFILE.TITLE_TASK)
                    LOCALDATA['attach_list'] = filtered_attachments
                    print(f"è¯»å– {len(filtered_attachments)} ä»½é™„ä»¶æ•°æ®ã€‚")
        elif user_input == '0':
            # åˆ é™¤ä¸´æ—¶æ•°æ®æ–‡ä»¶
            if title_file_exists:
                os.remove(LOCALDATA['temp_title_path'])
            if attach_file_exists:
                os.remove(LOCALDATA['temp_attach_path'])
            print("å·²åˆ é™¤ç¼“å­˜æ•°æ®ã€‚")
        else:
            print("æŒ‡ä»¤æ— æ•ˆã€‚")
        
        print('----------------------------------------')


# å¯åŠ¨æµè§ˆå™¨
def launch_webdriver():
    global driver

    prefs = {
        'download.directory_upgrade': True,
        'download.prompt_for_download': 'false',
        'profile.default_content_settings.multiple-automatic-downloads': 1,
        'download.default_directory': PROFILE.DOWNLOAD_FOLDER
    }

    options = webdriver.ChromeOptions()
    options.add_experimental_option('prefs', prefs)
    options.add_experimental_option('excludeSwitches', ['enable-logging'])
    options.add_argument(f'--user-data-dir={PROFILE.USERDATA_FOLDER}')
    options.add_argument('--window-size=1000,1200')
    options.add_argument('--disable-remote-fonts')
    options.add_argument('--ignore-certificate-errors')
    options.add_argument('--disable-gpu')
    options.add_argument('--no-sandbox')

    # æ£€æŸ¥ chromedriver æ˜¯å¦å­˜åœ¨
    chromedriver_path = os.path.join(os.getcwd(), 'chromedriver.exe')
    service = None
    if os.path.isfile(chromedriver_path):
        service = ChromeService(executable_path=chromedriver_path)
    driver = Chrome(options=options, service=service)
    driver.get(f"https://mail.qq.com/cgi-bin/loginpage")

    driver.find_element(By.CSS_SELECTOR, 'body').send_keys(Keys.END)
    login_panel = wait_until(driver, '#login')

    print(f"ç­‰å¾…ç™»å½•")
    start_wait_time = time.time()
    while wait_until(driver, '#login'):
        if time.time() - start_wait_time > 15:
            print("ç­‰å¾…æ—¶é—´ä¼¼ä¹æœ‰ä¸€æ®µæ—¶é—´ï¼Œå¦‚æœé¡µé¢å·²ç»ç™»å½•ï¼Œè¯·å°è¯•åˆ·æ–°é¡µé¢ã€‚")
            break
        time.sleep(1)

    # ç­‰å¾…ä¸»é¡µé¢åŠ è½½
    wait_until(driver, '#mainFrameContainer')
    LOCALDATA['token_sid'] = get_querystring(driver.current_url, 'sid')
    print(f"ç™»å½•æˆåŠŸï¼token_sid: {LOCALDATA['token_sid']}")


#-------------------------------------------------------------------------------
# Folder Title
#-------------------------------------------------------------------------------

# ç½‘é¡µè·³è½¬åˆ°æ–‡ä»¶å¤¹
# https://mail.qq.com/cgi-bin/mail_list?folderid=141&page=0&sid=xxxxx&nocheckframe=true

def open_folder():
    global driver
    LOCALDATA['token_page'] = PROFILE.PAGES_TASK['start']-1 if PROFILE.PAGES_TASK['start'] > 0 else 0
    driver.get(f"https://mail.qq.com/cgi-bin/mail_list?folderid={LOCALDATA['folder_id']}&page={LOCALDATA['token_page']}&sid={LOCALDATA['token_sid']}&nocheckframe=true")
    wait_until(driver, '#qqmail_mailcontainer')

    LOCALDATA['folder_name'] = driver.title.split(' - ')[1]
    LOCALDATA['title_count'] = int(find(driver, '#_ut_c').text)
    LOCALDATA['page_count'] = int(find(driver, '#frm > div > .right').text.split('/')[1].split(' é¡µ')[0].strip())
    LOCALDATA['page_title'] = len(find_all(driver, 'u.black'))
    print(f"* è¿›å…¥æ–‡ä»¶å¤¹: {LOCALDATA['folder_name']}(å…± {LOCALDATA['title_count']} å°)")


def get_title_list():
    global LOCALDATA

    driver.get(f"https://mail.qq.com/cgi-bin/mail_list?folderid={LOCALDATA['folder_id']}&page={LOCALDATA['token_page']}&sid={LOCALDATA['token_sid']}&nocheckframe=true")
    wait_until(driver, '#qqmail_mailcontainer')

    # å½“å‰æ–‡ä»¶å¤¹æœ‰å¤šå°‘å°é‚®ä»¶
    LOCALDATA['page_title'] = len(find_all(driver, 'u.black'))

    # è§£æå½“å‰é¡µçš„é‚®ä»¶æ•°æ®
    title_elements = find_all(driver, 'input[fa]')
    title_data = load_folder_title(title_elements)
    LOCALDATA['title_list'].extend(title_data)

    # ä¿å­˜æ•°æ®åˆ°ä¸´æ—¶æ–‡ä»¶
    save_to_csv(LOCALDATA['title_list'], LOCALDATA['temp_title_path'])
    LOCALDATA['token_page'] += 1


# å¤„ç†å•å°é‚®ä»¶çš„æ•°æ®
def load_title_data(element, index):
    parent = element.find_element(By.XPATH, 'ancestor::tbody')
    page = LOCALDATA['token_page']
    index = TEMP_DATA['title']
    fromname = element.get_attribute('fn')
    address = element.get_attribute('fa')
    timestamp = element.get_attribute('totime')
    mailid = element.get_attribute('value')
    title = find(parent, 'u.black.tt').text
    star = 1 if element.get_attribute('star') == 1 else 0
    unread = 1 if element.get_attribute('unread') == 'true' else 0
    attach = 1 if find_all(parent, '.cij.Ju') else 0
    tags = get_title_tag(parent) if find_all(parent, '.TagDiv') else ''

    data = [{
        'page': page,
        'index': index,
        'fromname': fromname,
        'title': title,
        'address': address,
        'pageat': index,
        'attach': attach,
        'star': star,
        'tags': tags,
        'unread': unread,
        'mailid': mailid,
        'timestamp': timestamp,
    }]

    return data

# å¤„ç†æ–‡ä»¶å¤¹é‚®ä»¶çš„æ•°æ®
def load_folder_title(elements):
    global driver
    data_list = []
    for i, e in enumerate(elements, start=0):
        data = load_title_data(e, i)
        if title_task_exit():
            TEMP_DATA['nextpage'] = 0
            break
        data_list.extend(data)
        TEMP_DATA['title'] += 1
    return data_list

#-------------------------------------------------------------------------------
# Mail
#-------------------------------------------------------------------------------

def can_open_email(data):
    if PROFILE.SKIP_NO_ATTACH and not bool(data['attach']):
        print(f"- {data['index']} {data['title']} æ²¡æœ‰é™„ä»¶ï¼Œå·²è·³è¿‡ã€‚")
        return False
    if contains_keywords(data['title'], PROFILE.TITLE_BACKLIST_KEYS):
        print(f"- {data['index']} {data['title']} æ ‡é¢˜åç§°åŒ…å«é»‘åå•")
        return False
    return True


def open_mail():
    print('å¼€å§‹è¯»å–é‚®ä»¶ï¼Œæ”¶é›†é™„ä»¶ä¿¡æ¯')
    global driver, LOCALDATA
    with ThreadPoolExecutor() as executor:
        with open(LOCALDATA['temp_title_path'], 'r', newline='', encoding='utf-8') as csvfile:
            folder = csv.DictReader(csvfile)
            for title in folder:
                # æ£€éªŒé‚®ä»¶åæ˜¯å¦åŒ…å«é»‘åå•å…³é”®è¯ï¼Œä»¥åŠé™„ä»¶æƒ…å†µã€‚
                if can_open_email(title):
                    driver.get(f"https://mail.qq.com/cgi-bin/frame_html?t=newwin_frame&sid={LOCALDATA['token_sid']}&url=/cgi-bin/readmail?t=readmail%26mailid={title['mailid']}%26mode=pre")
                    wait_until(driver, '#pageEnd')
                    driver.switch_to.frame("mainFrame")
                    driver.find_element(By.CSS_SELECTOR, 'body').send_keys(Keys.END)
                    # å¤„ç†æ²¡æœ‰é™„ä»¶ï¼Œæ˜¯å¦éœ€è¦åŠ æ˜Ÿæ ‡å’Œæ ‡ç­¾
                    if not title['attach']:
                        print(f"- æ²¡æœ‰é™„ä»¶: ç¬¬{title['index']}å°é‚®ä»¶ä½äºç¬¬{title['page']}é¡µ. | {title['name']} {title['title']} {title['address']}")
                        # è®¾ä¸ºæ˜Ÿæ ‡
                        if bool(PROFILE.CAN_STAR_NO_ATTACH):
                            add_mail_star()
                        # æ·»åŠ æ ‡ç­¾
                        if bool(PROFILE.CAN_TAG_NO_ATTACH):
                            add_mail_tag(PROFILE.STR_TAG_NO_ATTACH)
                    else:
                        # è·å–é™„ä»¶å…ƒç´ 
                        attach_elements = find_all(driver, '.ico_big a')
                        attach_tasks = []
                        # è·å–æ¯ä¸ªé™„ä»¶ä¿¡æ¯
                        for item in attach_elements:
                            attach_info = load_attach_data(item, title)
                            LOCALDATA['attach_list'].append(attach_info)
                            attach_tasks.append(attach_info)
                        TEMP_DATA['attach'] += len(attach_elements)
                        save_to_csv(LOCALDATA['attach_list'], LOCALDATA['temp_attach_path'])

# è¯»å–å•ä¸ªé™„ä»¶çš„ä¿¡æ¯
def load_attach_data(element, title_data):
    title_index = title_data['index']
    attach_index = TEMP_DATA['attach'] + int(element.get_attribute('idx') or 0)
    fileindex = int(element.get_attribute('idx') or 0)
    fromname = title_data['fromname']
    filename = element.get_attribute('filename')
    filebyte = int(element.get_attribute('filebyte'))
    fileview = element.get_attribute('viewmode')
    filedown = f"https://mail.qq.com{element.get_attribute('down')}"
    title = title_data['title']
    address = title_data['address']
    mailid = title_data['mailid']
    timestamp = title_data['timestamp']
    page = title_data['page']
    pageat = title_data['pageat']
    data = {
        'title_index': title_index,
        'attach_index': attach_index,
        'fromname': fromname,
        'filename': filename,
        'filebyte': filebyte,
        'fileview': fileview,
        'filedown': filedown,
        'fileindex': fileindex,
        'title': title,
        'address': address,
        'mailid': mailid,
        'timestamp': timestamp,
        'page': page,
        'pageat': pageat,
    }
    return data


#-------------------------------------------------------------------------------
# Task
#-------------------------------------------------------------------------------

# æ£€æµ‹ä»€ä¹ˆæ—¶å€™ç»“æŸç¿»é¡µ
def page_task_exit():
    page_out = LOCALDATA['token_page'] >= LOCALDATA['page_count']
    page_step_out = PROFILE.PAGES_TASK['step'] > 0 and PROFILE.PAGES_TASK['start'] + LOCALDATA['token_page'] > PROFILE.PAGES_TASK['step']
    page_end_out = PROFILE.PAGES_TASK['end'] > 0 and LOCALDATA['token_page'] > PROFILE.PAGES_TASK['end']
    title_task_out = not TEMP_DATA['nextpage']
    return page_out or page_step_out or page_end_out or title_task_out

# æ£€æµ‹ä»€ä¹ˆæ—¶å€™åœæ­¢æ”¶é›†é‚®ä»¶æ ‡é¢˜
def title_task_exit():
    title_step_out = PROFILE.TITLE_TASK['step'] > 0 and PROFILE.TITLE_TASK['start'] + TEMP_DATA['title'] >= PROFILE.TITLE_TASK['step']
    title_end_out = PROFILE.TITLE_TASK['end'] > 0 and PROFILE.TITLE_TASK['start'] + TEMP_DATA['title'] >= PROFILE.TITLE_TASK['end']
    return title_step_out or title_end_out

# æ£€æµ‹å­—ç¬¦ä¸²æ˜¯å¦åŒ…å«å…³é”®è¯
def contains_keywords(title, list):
    if not list:
        return
    for key in list:
        if key in title:
            return True
    return False

#-------------------------------------------------------------------------------
# file
#-------------------------------------------------------------------------------

# æ ¹æ®é‚®ä»¶æä¾›çš„æ–‡ä»¶å±æ€§ï¼Œåˆ¤æ–­æ–‡ä»¶åæ˜¯å¦è§„èŒƒã€‚
# è¿™é‡Œä¸ºç®€å•åˆ¤æ–­ï¼Œæ–‡ä»¶åæ˜¯å¦åŒ…å«6ä»¥ä¸Šçš„æ•°å­—ï¼Œæ¥åŒºåˆ†æ˜¯å¦åŒ…å«QQå·ã€‚
def verify_filename_matching(filename):
    pattern = r'\d{6,}'
    return bool(re.search(pattern, filename))


# æ ¹æ®é‚®ä»¶æä¾›çš„æ–‡ä»¶å±æ€§ï¼Œåˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œä¸”æ–‡ä»¶å¤§å°ç›¸åŒ
def verify_file_matching(filename, expected_byte):
    path = os.path.join(PROFILE.DOWNLOAD_FOLDER, filename)
    if os.path.isfile(path):
        actual_byte = os.path.getsize(path)
        return True, actual_byte == expected_byte
    return False, False

# ä»åˆ—è¡¨ä¸‹è½½æ‰€æœ‰é™„ä»¶
def download_attach_list(attach_list):
    if not bool(attach_list):
        return
    with ThreadPoolExecutor(max_workers=PROFILE.MAX_CONCURRENT_DOWNLOADS) as executor:
        futures = [executor.submit(download_thread, item) for item in attach_list]
        for future in as_completed(futures):
            result = future.result()


def download_thread(attach_data):
    print(f"å³å°†ä¸‹è½½: ç¬¬{attach_data['attach_index']}ä¸ªé™„ä»¶ï¼Œæ¥è‡ªç¬¬{attach_data['title_index']}å°é‚®ä»¶ã€‚ {attach_data['filename']}ã€‚{attach_data['fromname']}-{attach_data['title']}")
    # æ ¹æ®æ˜¯å¦è·³è¿‡æ–‡ä»¶ï¼Œå†³å®šæ˜¯å¦ä¸‹è½½æ–‡ä»¶å’Œè¾“å‡ºæç¤ºä¿¡æ¯
    if PROFILE.SKIP_EXISTS_FILE:
        download_and_wait(attach_data['filedown'], attach_data)
    else:
        download_file(attach_data['filedown'])
    return attach_data


# å®é™…ä¸‹è½½ä¸€ä¸ªæ–‡ä»¶
def download_file(url):
    global driver
    driver.get(url)
    time.sleep(0.5)

# ä¸‹è½½å¹¶ç­‰å¾…
def download_and_wait(file_url, attach_data):
    download_file(file_url)
    target_file = os.path.join(PROFILE.DOWNLOAD_FOLDER, attach_data['filename'])
    timeout = PROFILE.DOWNLOAD_TIME_OUT
    while timeout > 0:
        if skip_file_matching(target_file, attach_data['filebyte']):
            print(f"ä¸‹è½½å®Œæˆ: {target_file}")
            # æ˜¯å¦éœ€è¦ç§»åŠ¨åˆ°æ–‡ä»¶å¤¹
            if PROFILE.CREATE_FOLDER_EACH_TITLE:
                move_file_to_folder(attach_data['filename'], attach_data)
                return True
        time.sleep(1)
        timeout -= 1
    print(f"ä¸‹è½½è¶…æ—¶: {attach_data['filename']} ({read_bytes(attach_data['filebyte'])})")
    return False

# ç§»åŠ¨åˆ°æ–‡ä»¶å¤¹
def move_file_to_folder(filename, attach_data):

    folder_root = PROFILE.DOWNLOAD_FOLDER
    folder_name = StringSub(PROFILE.CREATE_FOLDER_NAME, attach_data)

    folder_path = os.path.join(folder_root, folder_name)
    
    if not os.path.exists(folder_path):
        try:
            os.makedirs(folder_path)
        except FileExistsError:
            pass

    old_path = os.path.join(folder_root, filename)
    new_path = os.path.join(folder_path, filename)

    # é¿å…ç›®æ ‡è·¯å¾„é‡åå†²çª
    if os.path.exists(new_path):
        base, extension = os.path.splitext(filename)
        i = 1
        while os.path.exists(new_path):
            new_path = os.path.join(folder_path, f"{base}_{i}{extension}")
            i += 1
    
    try:
        shutil.move(old_path, new_path)
    except Exception as e:
        print(f"æ— æ³•ç§»åŠ¨æ–‡ä»¶ {filename}: {e}")

#-------------------------------------------------------------------------------
# Utility
#-------------------------------------------------------------------------------

def find(elements, selector):
    try:
        return elements.find_element(By.CSS_SELECTOR, selector)
    except:
        return None

def find_all(elements, selector):
    try:
        return elements.find_elements(By.CSS_SELECTOR, selector)
    except:
        return None

def wait_until(elements, selector, timeout=8):
    try:
        return WebDriverWait(elements, timeout).until(EC.visibility_of_element_located((By.CSS_SELECTOR, selector)))
    except:
        return None

def check_file_download(path, expected_name, expected_byte):
    file_path = os.path.join(path, expected_name)
    return os.path.exists(expected_name) and os.path.getsize(expected_name) == expected_byte

# é¢‘ç¹æç¤ºï¼Œè‡ªåŠ¨åˆ·æ–°è‡³å…ƒç´ æ¶ˆå¤±
def FBI_WAITTING(id):
    global driver
    if not find(driver, id):
        return
    wait = 0
    while find(driver, id):
        if wait == 0: time.sleep(10); driver.navigate().refresh()
        elif wait == 2: time.sleep(6); driver.navigate().refresh()
        elif wait%3 == 0: time.sleep(3); driver.navigate().refresh()
        else:time.sleep(1)
        wait+=1


# æ·»åŠ æ ‡ç­¾ï¼Œè‹¥æ ‡ç­¾å·²ç»å­˜åœ¨åˆ™è·³è¿‡ï¼Œè‹¥æ ‡ç­¾ä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºæ ‡ç­¾ã€‚
def add_mail_tag(tagname):
    global driver
    if find(driver,'#tagContainer') and tagname in find(driver, '#tagContainer').text:
        return
    driver.find_element(By.LINK_TEXT, 'æ ‡è®°ä¸º...').click()
    if tagname not in find(driver,'#select_QMMenu__menuall_').text:
        print(f"æ ‡ç­¾ {tagname} ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»ºæ ‡ç­¾ã€‚")
        new_mail_tag(tagname)
        return
    driver.find_element(By.LINK_TEXT, 'æ ‡è®°ä¸º...').click()
    cancel_tag_element = driver.find_element(By.XPATH, "//span[contains(text(), 'å–æ¶ˆæ ‡ç­¾')]")
    driver.execute_script("arguments[0].nextElementSibling.click();", cancel_tag_element)


# æ·»åŠ æ˜Ÿæ ‡ï¼Œè‹¥å·²æ˜Ÿæ ‡åˆ™å¿½ç•¥
def add_mail_star():
    global driver
    if find(driver, '#img_star').get_attribute('class') == 'qm_ico_flagoff':
        driver.find_element(By.CSS_SELECTOR, '#img_star').click()


# æ–°å»ºæ–°çš„æ ‡ç­¾
def new_mail_tag(tagname):
    global driver
    driver.find_element(By.LINK_TEXT, 'æ–°å»ºæ ‡ç­¾').click()
    driver.find_element(By.CSS_SELECTOR, '#QMconfirm_QMDialog_txt').send_keys(tagname)
    driver.find_element(By.LINK_TEXT, 'ç¡®å®š').click()


# è·å–é‚®ä»¶çš„æ ‡ç­¾åˆ—è¡¨
def get_title_tag(elements):
    tag_tds = find_all(elements, '.tagbgSpan')
    tags = []
    for td in tag_tds:
        tags.append(td.text.strip())
    return ', '.join(filter(None, tags))


# ä»URLé“¾æ¥ä¸­æå–å‚æ•°
def get_querystring(url, item):
    data = dict(parse.parse_qsl(parse.urlsplit(url).query))
    try:
        return data[item]
    except:
        print(f"æ‰¾ä¸åˆ° {data} ä¸­çš„ {item} å‚æ•°")
        return None


# å°†æ•°æ®å‚¨å­˜åˆ°csvæ–‡ä»¶ä¸­
def save_to_csv(data_list, filepath):
    if not data_list:
        return
    keys = data_list[0].keys()
    with open(filepath, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, keys)
        writer.writeheader()
        for data in data_list:
            data = {key: data[key] for key in keys}
            writer.writerow(data)
    

# æ ¹æ®ä¸‹è½½è®¡åˆ’çš„é…ç½®, ç­›é€‰ç¬¦åˆçš„ä¸‹è½½èŒƒå›´
def apply_download_schedule(data_list, task):
    start = task.get('start', 1) - 1 or 0
    end = task.get('end') or len(data_list)
    step = task.get('step') or len(data_list)
    selected_data = data_list[start:min(start + step, end)]
    return selected_data

# è¯»å–æ–‡ä»¶å¤¹çš„ä½œå“æ•°é‡ï¼Œé€šè¿‡æ¯”è¾ƒæ–‡ä»¶åå‰é¢10ä¸ªå­—ç¬¦
def get_unique_filenames(folder_path):
    filenames = os.listdir(folder_path)
    unique_names = set()
    for filename in filenames:
        unique_names.add(filename[:10])
    return len(unique_names)


# æ ¹æ®é‚®ä»¶æä¾›çš„æ–‡ä»¶å±æ€§ï¼Œåˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œä¸”æ–‡ä»¶å¤§å°ç›¸åŒ
def skip_file_matching(filename, filesize):
    folder_root = PROFILE.DOWNLOAD_FOLDER
    filepath = os.path.join(folder_root, filename)
    # æ£€æŸ¥æ–‡ä»¶åå’Œæ–‡ä»¶å¤§å°æ˜¯å¦åŒ¹é…
    if os.path.isfile(filepath) and os.path.getsize(filepath) == filesize:
        return True
    # æ›¿æ¢ç‰¹æ®Šå­—ç¬¦ï¼Œç§»é™¤ä¸å¯æ‰“å°å­—ç¬¦
    legal_filename = validateName(filename)
    # å°è¯•æ˜¯å¦å’ŒåŸå§‹æ–‡ä»¶åŒ¹é…
    if os.path.isfile(legal_filename) and os.path.getsize(legal_filename) == filesize:
        return True
    return False

#æå–æ–‡ä»¶å
def get_filename(string):
    return string.split(".")[0] if len(string.split('.')) <= 1 else '.'.join(string.split('.')[0:-1])

# å»é™¤ä¸å¯è§å­—ç¬¦
def validateName(filename):
    legal_filename = re.sub(r'[\/|\\|\:|\*|\?|\"|\<|\>|\||\.|]', '', filename)
    legal_filename = re.sub(r'[\\/:"*?<>|]+', '', filename)
    legal_filename = ''.join(filter(lambda x: x.isprintable(), legal_filename))
    return legal_filename

# è¡¥é›¶
def zerofill(n):
    n = n if type(n) == type(1) else int(n)
    z = 2
    if n >= 10000:
        z=5
    elif n>=1000 and n<10000:
        z=4
    elif n>=100 and n<1000: 
        z=3
    else:
        z=2
    return str(n).zfill(z)


# è¾“å‡ºæ–‡ä»¶å¤§å°
def read_bytes(bytes):
    if bytes == 0:
        return "0KB"
    size = ("B", "KB", "MB", "GB", "TB")
    i = 0
    while bytes >= 1024 and i < len(size)-1:
        bytes /= 1024.0
        i += 1
    return "{:.2f} {}".format(bytes, size[i])

def StringSub(string, data):
    timestamp = time.localtime(float(int(data['timestamp']) / 1000))

    # é‡å‘½åè§„åˆ™æ¨¡æ¿
    rule = { 
        '{folderid}': str(PROFILE.FOLDER_ID),                                # æ–‡ä»¶å¤¹ID
        '{filename}': get_filename(validateName(data['filename'])),          # æ–‡ä»¶å file
        '{filenameEx}': validateName(data['filename']),                      # æ–‡ä»¶å file.jpg
        '{filetype}': data['filename'].split('.')[-1].lower(),               # æ–‡ä»¶ç±»å‹ jpg
        '{titleindex}': str(data['title_index']),                            # æ ‡é¢˜é¡ºåº
        '{attchindex}': str(data['attach_index']),                           # é™„ä»¶é¡ºåº
        '{page}': str(data['page']),                                         # é‚®ä»¶ä½äºç¬¬å‡ é¡µ
        '{pageat}': str(data['pageat']),                                     # é‚®ä»¶ä½äºç¬¬å‡ é¡µçš„ç¬¬å‡ å°
        '{titlecount}': str(len(LOCALDATA['title_list'])),                   # æ€»é‚®ä»¶æ•°é‡
        '{attchcount}': str(len(LOCALDATA['attach_list'])),                  # æ€»æ ‡é¢˜æ•°é‡
        '{tokenpage}': str(LOCALDATA['token_page']),                         # å½“å‰ä½äºç¬¬å‡ é¡µ
        '{foldername}': validateName(LOCALDATA['folder_name']),              # æ–‡ä»¶å¤¹åç§°
        '{foldertitle}': str(LOCALDATA['title_list']),                       # æ–‡ä»¶å¤¹é‚®ä»¶æ•°é‡ï¼š500
        '{pagecount}': str(LOCALDATA['page_count']),                         # æ–‡ä»¶å¤¹é¡µæ•°ï¼š002
        '{titlename}': validateName(data['title']),                          # é‚®ä»¶æ ‡é¢˜
        '{fromname}': validateName(data['fromname']),                        # å‘ä¿¡äººæ˜µç§°
        '{mailid}': data['address'].split("@")[0],                           # é‚®ç®±IDï¼š123456
        '{mailaddress}': data['address'],                                    # é‚®ç®±åœ°å€ï¼š123456@qq.com
        '{year}': time.strftime("%Y", timestamp),                            # å¹´ï¼š2020
        '{month}': time.strftime("%m", timestamp),                           # æœˆï¼š11
        '{day}': time.strftime("%d", timestamp),                             # æ—¥ï¼š04
        '{week}': time.strftime("%a", timestamp),                            # å‘¨ï¼šWed
        '{ampm}': time.strftime("%p", timestamp),                            # åˆï¼šPM
        '{hours}': time.strftime("%H", timestamp),                           # æ—¶ï¼š14
        '{minutes}': time.strftime("%M", timestamp),                         # åˆ†ï¼š30
        '{seconds}': time.strftime("%S", timestamp),                         # ç§’ï¼š59
        '{time1}': time.strftime("%H%M", timestamp),                         # 1430
        '{time2}': time.strftime("%H-%M-%S", timestamp),                     # 14-30-59
        '{time3}': time.strftime("%H'%M'%S", timestamp),                     # 14'30'59
        '{date1}': time.strftime("%m%d", timestamp),                         # 1207
        '{date2}': time.strftime("%Y%m%d", timestamp),                       # 20201207
        '{date3}': time.strftime("%Y-%m-%d", timestamp),                     # 2020-12-07
        '{fulldate1}': time.strftime("%Y-%m-%d_%H-%M-%S", timestamp),        # 2020-12-07_14-30-59
        '{fulldate2}': time.strftime("%Y%m%d_%H'%M'%S", timestamp),          # 20201207_14'30'59
    }

    for i, j in rule.items(): 
        string = string.replace(i, j)
    
    return string

#-------------------------------------------------------------------------------
# START
#-------------------------------------------------------------------------------
def main():
    launch_webdriver()
    open_folder()
    load_temporary_data()
    if not LOCALDATA['attach_list']:
        if not LOCALDATA['title_list']:
            while not page_task_exit():
                get_title_list()
        else:
            print(f"ä»ç¼“å­˜æ•°æ®å¼€å§‹ï¼Œè·å–{len(LOCALDATA['title_list'])}å°é‚®ä»¶çš„é™„ä»¶åˆ—è¡¨ã€‚")
        open_mail()
    else:
        print('ä»ç¼“å­˜æ•°æ®å¼€å§‹ï¼Œç›´æ¥ä¸‹è½½é™„ä»¶åˆ—è¡¨çš„æ–‡ä»¶')
    
    # ä¸‹è½½é™„ä»¶åˆ—è¡¨çš„é™„ä»¶
    if PROFILE.CAN_DOWNLOAD_ATTACH:
        download_attach_list(LOCALDATA['attach_list'])


if __name__ == '__main__':
    os.system('cls')
    main()
    print('å®Œæˆã€‚')
    print("é‚®ä»¶æ€»æ•°: ", LOCALDATA['title_count'])
    print("é¢„ä¼°æ–‡ä»¶å¤¹å­˜åœ¨çš„ä½œå“æ•°: ", get_unique_filenames(PROFILE.DOWNLOAD_FOLDER))
    input('')
